Why is C++ so hard? How can I improve my skills?
Omar Baltuth
Omar Baltuth, Coding up a storm since 1977!
Answered Jul 27, 2016 · Upvoted by Vaughn Cato, Programming in C++ for 25 years · Author has 375 answers and 1.1m answer views
C++ is no joke; it’s the real thing, a language for serious programmers who know what they’re doing. I’ve always felt that I was “good” at writing code and confident, even cocksure about tackling any programming job. Once I figured out how to approach it, I would start coding up a storm. C++ is the only language that ever gave me pause and question whether or not I had what it takes to be a real computer scientist rather than just the holder of an advanced degree in that discipline. It’s hard to learn and use, but there is a compelling reason for including each troublesome feature.

There’s the story that Bjarne Stroustrup, the originator of the language at Bell Labs, was trying to invent a computer programming language so arcane and complex that no one except him would be able to use it. If he was actually thinking that, he screwed up because he didn’t count on the persistence and deep intellect of his fellow computer scientists. Those who bit the bullet and learned how to program effectively in C++ discovered its power and elegance.

They soon realized that this was a workhorse language, one that could be used to program anything, and that it was the best language available to write consumer software. In those days, we were constrained by memory and storage and most software was distributed on hard media. (No hasty, slapdash releases allowed!) Code had to be tight and rock solid in order to justify being developed at all, let alone distributed to the world at large.

C was great, and it had revolutionized the programming of dedicated devices, but it needed to be scaled up to “model the world”. For that, Stroustrup looked to languages like Simula and Ada. He had become enamored of object-oriented programming as a theory and wanted to use that approach in the software development projects he was working on at Bell Labs. So, he took C, the incredibly efficient language they had, and wrapped it in new constructs to support object-oriented programming.

What happened in doing that is what made C++ “hard”. The idea of objects with properties and methods was just too abstract for most programmers to fully grasp. I still have trouble with that, and I made a living writing code for over 30 years, including 13 writing mostly in C++. But, once you get how things are done, it becomes obvious why all “important” consumer applications around today are written with C++. You can easily do stuff with it that no other popular language does nearly as well. It’s slick, elegant and totally unforgiving.

That last quality is as much responsible for making C++ a difficult language as are its stultifyingly convoluted constructs. But, rigidity of syntax is also a blessing because it does not countenance lazy thinking. You can’t just cast a void* as something you want, hoping that everything will work out. The compiler will bitch at you and spit up. It protects you from hosing up your code with disorganized, confused junk that will never work. You’ve got to figure out what you’re doing and then design classes that elegantly model the real world. Those classes must contain properties and methods that get the job done. You’ve got to get all your ducks in a row and knock them off one by one. That’s hard work and there is no substitute for it. While you can do that with just about any language, you pretty much have to be well-organized with C++ or you won’t be able to succeed at all.

Of course, what puts most people off the most is the stuff that is hard to understand and learn to use. The first time I saw a template I almost freaked out. “What do you mean putting stuff between ‘<’ and ‘>’?” Once I calmed down, I got it: Templates facilitate extensibility and makes it possible to streamline code, ridding it of repetitive complexity. Nice. That’s how it generally goes in learning C++ features. You see some code or an example in a textbook that makes no sense, you learn it, then you put it to use. Once you’ve gone through that process with a language feature, you understand why they have it, and it suddenly makes sense. After a while, you wonder how you ever got along without that feature. You might even wonder how less sophisticated languages without that feature get anything done.

Every complex construct has a reason. Do you not like references because they seem to needlessly replicate pointers? There’s a reason for it, subtle, but real. There’s also the joke that when Stroustrup’s colleagues laughed a his first cut at an inscrutably hard language, saying that it was trivial, he said, “Oh, yeah?” Then, he went back to his lair and didn’t emerge until he had added references and templates. That’s plausible, but not probable. Good joke, though.

Here are some more examples. Why is some argument to a method “const”? They don’t want you to mess with it inside your method. If you’re writing the code, it shows that you know that you’re not supposed to mess with the argument in the method, and if you do so accidentally, the compiler will balk. Why all this “public” and “private” stuff? Same reason; C++ prevents you from shooting yourself in the foot and hosing up your objects. The complexity and rigidity of the syntax enforced by the compiler is your guardian as well as your overseer.

In the end, one has to concede that C++ is hard to learn and use because it has to be. Once you accept that premise, you’ll be more likely to buckle down and learn it.

There’s another good reason to always take the extra effort to learn “hard” computer languages, job insurance. In 1990, I was working at an engineering firm. I had been hired to write code in C and assembly language for in-flight avionic systems. A new manager was wandering around the bullpen recruiting people for a new group that would develop PC-based ground support software to automate the work being done with the airborne equipment between flights.

We had just adopted Windows as our OS and everyone was playing solitaire and Minesweeper to learn how to use a mouse. We still did all our work with MS-DOS based tools in a command prompt window. The manager asked us if we wanted to switch from writing firmware to writing PC applications to run under Windows. Nearly everyone recoiled in horror and didn’t want any part of Windows. They were terrified of a GUI environment, or they were wary of programming in anything but C or assembly language. The manager had said that we could do our work in C, but he was curious about this newfangled C++ thing and wanted some bold programmers to work with him and make the decision between C and C++.

I and all the other coders who considered themselves primarily as programmers rather than electronic engineers jumped at the chance to escape the living hell we were enduring as firmware monkeys. We all pushed hard for C++, the new language for which we had all hastily run out and purchased a textbook to learn it before we were required to write something using it. None of us had any experience with it because it wasn’t taught in college, no one had a compiler, and very few ordinary people had software development tools on their home computers. We were taking a leap of faith, one that most people dared not attempt.

That gamble paid off. C++ took off and a lot of the less daring people in that bullpen started to get laid off. The C++ programmers became stars of a sort. We were the people who made magical graphic apps run under Windows. Everyone else was polishing crap code for embedded systems designed by engineers who knew nothing about programming as a professional discipline. They worked in MS-DOS at a command line, usually with light grey characters on a black screen. (Few people knew how to change the colors.) They were idiots for the most part and everyone knew it.

A few years later, an unscrupulous firm bought ours and laid off half the employees on the first day. They fired all the Windows programmers because some French avionics firm had blown smoke up their ass about being able to do the work we did under Windows faster and cheaper with their “superior” language, Pascal. (Yes, Pascal!) About six months later, they had realized their error and were putting big ads in the paper trying to hire Windows programmers who knew C++. It was too late. All the C++ programmers got jobs quickly because we knew the hot developer language. I got a job at Microsoft, which didn’t last, but I worked steadily for the next 13 years, principally in C++, at Microsoft and other firms.

The coda is that C++ waned in popularity as an employment draw because, I suspect, all the good jobs were filled by good C++ programmers hanging on for dear life as the job market ebbed and waned. After a while, if you wanted work, you had to know something new, like Java, SQL or Javascript. I kept seeing ads for programmers in this new language, C#. I read a couple of books and soon got work writing C#. That served me well enough until I threw in the towel and decided that playing guitar and writing blogs suited my tastes better.

Did I mention that learning the new, “hard” language every few years kept me employed and fairly well-paid for my entire career? Always do that and you’ll never starve. I started work as a COBOL programmer even though I had studied several others and was better at them. It was a job and I made a living because COBOL was still hot stuff in 1977. Soon, I switched to writing FORTRAN and Z-80 assembler at another firm. When they needed someone to do something in COBOL or Pascal, I was the go-to guy because no one else knew those languages. After several years, I started hearing about C and spent two years looking for a job writing it as I read books. An out-of-state firm recruited me to do that, so I packed up and moved. The straight C jobs only lasted about four years before I picked up on C++ at the avionics company and made a transition to that language. Every time I switched languages, either by necessity or choice, I moved up in salary. And, every new language was always hard, very, very hard to learn.

The difficulty of the language guarantees that your skill in writing it will get you the big bucks. If it were easy, they could get someone from the local community college to do the job and pay them peanuts. And, that, my friend, is really why C++ is so damned hard to learn. Bjarne Stroustrup wanted be so valuable and important to Bell Labs that he would never, ever, have to look for a job. C++ was his “golden goose”. Inventing and maintaining it made his career.

